import { Crypto } from 'bitbox-sdk/lib/Crypto';
import { Address } from 'bitbox-sdk/lib/Address';
import { RawTransactions } from 'bitbox-sdk/lib/RawTransactions';
import { REST_URL, TREST_URL } from 'bitbox-sdk/lib/BITBOX';

import { BITCOINCASH_CMDID, BitcoinCash } from 'kelvinjs-protob';

import {
  ICurrencyUtil,
  IArmadilloCommand,
  IArmadilloResponse,
  ISignTxRequest,
  ITransaction,
  ITransactionSchema,
} from './api';

import { selectUtxos, OutMode } from './selectUtxos';

// ---------------------------------------------------------------------------

const bbCrypto = new Crypto();
const bbAddr = new Address(REST_URL);
const tbbAddr = new Address(TREST_URL);
const bbRawTx = new RawTransactions(REST_URL);
const tbbRawTx = new RawTransactions(TREST_URL);

const { BchCommand, BchResponse } = BitcoinCash;
const { BchShowAddr, BchGetXPub, BchSignTx } = BchCommand;
const { BchTxIn, BchTxOut } = BchSignTx;

// ---------------------------------------------------------------------------

const MIN_SAT_TO_SEND = 10000; // 0.00010000 BCH
const MAX_SAT_TO_SEND = 99999999999999; // 999,999.99999999 BCH

const DUST_TXOUT_FEE_RATE = 3000; // do not generate such dust txouts
const DISCARD_CHANGE_FEE_RATE = 3000; // do not generate such change txouts

const MIN_FEE_RATE_SAT_PER_KVB = 1000; // fee rate at least 1000 sat per kvb
const MAX_FEE_RATE_SAT_PER_KVB = 1000000; // fee rate at most 0.01 BCH per kvb
const MAX_FEE_TOTAL = 99999999; // total fee at most 0.99999999 BCH

const MAX_TXOUT_IDX = 99999;

// ---------------------------------------------------------------------------

function validateOrThrowErr(itemName: string, x: boolean): void {
  if (!x) {
    throw Error(`invalid ${itemName}`);
  }
}

function w<T>(e: string | ((x: any) => string), t: () => T): T {
  // Catch error and throw a new error with a specific error message, or just
  // return the value generated by a function call.
  try {
    return t();
  } catch (x) {
    if (typeof e === 'string') {
      throw Error(e);
    } else {
      throw Error(e(x));
    }
  }
}

// ---------------------------------------------------------------------------

function isObject(x: any): x is { [x: string]: any } {
  return typeof x === 'object' && x !== null && !isArray(x);
}

function isArray(x: any): x is any[] {
  return Array.isArray(x);
}

// ---------------------------------------------------------------------------

function isNumber(x: any): x is number {
  return typeof x === 'number';
}

function isNonNegativeInteger(x: any): x is number {
  // How about renaming this function to isUint53
  return isNumber(x) && Number.isSafeInteger(x) && x >= 0;
}

function isValidTxoutIndex(n: any): n is number {
  return isNonNegativeInteger(n) && n <= MAX_TXOUT_IDX;
}

function isValidBlockchainTimestamp(n: any): n is number {
  // the unit is seconds (not milliseconds)
  const LOW = 1230768000; // 2009-01-01T00:00:00Z
  const UPP = 4102444800; // 2100-01-01T00:00:00Z
  return isNonNegativeInteger(n) && n >= LOW && n <= UPP;
}

function isValidAmountNum(v: any): v is number {
  return isNonNegativeInteger(v) && v <= 21e14;
}

function isValidAccIdx(accountIndex: number): boolean {
  return isNonNegativeInteger(accountIndex) && accountIndex <= 0x7fffffff;
}

// ---------------------------------------------------------------------------

function isString(x: any): x is string {
  return typeof x === 'string';
}

function isNonNegativeDecimalStr(s: any): s is string {
  return isString(s) && /^(0|[1-9][0-9]*)$/.test(s);
}

function isValidTransactionId(s: any): s is string {
  return isString(s) && /^[0-9a-f]{64}$/.test(s);
}

function isValidAmountStr(s: any): s is string {
  return (
    isNonNegativeDecimalStr(s) &&
    (s.length <= 15 || (s.length === 16 && s <= '2100000000000000'))
  );
}

function isValidAmountToPayStr(s: any): s is string {
  return isValidAmountStr(s) && +s >= MIN_SAT_TO_SEND && +s <= MAX_SAT_TO_SEND;
}

function isValidFeeRateToPayStr(s: any): s is string {
  return (
    isValidAmountStr(s) &&
    +s >= MIN_FEE_RATE_SAT_PER_KVB &&
    +s <= MAX_FEE_RATE_SAT_PER_KVB
  );
}

function isValidNetwork(s: string): boolean {
  return ['mainnet', 'testnet'].includes(s);
}

function isValidHexString(s: string): boolean {
  return /^([0-9a-f]{2})*$/.test(s);
}

function isValidPubKey(s: string): boolean {
  // Because we are lazy, we do not actually check whether the provided values
  // (X, Y) is indeed a valid EC point on the curve secp256k1
  return /^04[0-9a-f]{128}$/.test(s);
}

// ---------------------------------------------------------------------------

function truncateToSixDecimals(x: string): string {
  const regexMatch = x.match(/^.*\..{6}/);
  if (regexMatch !== null) {
    return regexMatch[0];
  }
  return x;
}

function compressPubKey(input: Buffer): Buffer {
  if (!(input.length === 65 && input[0] === 0x04)) {
    throw Error(`invalid input ${input.toString('hex')}`);
  }
  return Buffer.concat([
    Buffer.from([0x02 + (input[64] & 0x01)]),
    input.slice(1, 1 + 32),
  ]);
}

// Return an array of zero or more [txId, outIdx, value] tuples
export async function getUnspentTxOuts(
  network: string,
  addr: string
): Promise<Array<[string, number, number]>> {
  validateOrThrowErr('network', isValidNetwork(network));
  validateOrThrowErr('addr', isValidAddr(network, addr));

  // Result includes confirmed and unconfirmed ones
  const utxosLookupRes = await (network === 'mainnet' ? bbAddr : tbbAddr).utxo(
    addr
  );
  if (
    !((
      x: any
    ): x is {
      utxos: Array<{
        txid: string;
        vout: number;
        satoshis: number;
        confirmations: number;
      }>;
    } =>
      isObject(x) &&
      isArray(x.utxos) &&
      x.utxos.every(
        e =>
          isValidTransactionId(e.txid) &&
          isValidTxoutIndex(e.vout) &&
          isValidAmountNum(e.satoshis) &&
          isNonNegativeInteger(e.confirmations)
      ))(utxosLookupRes)
  ) {
    throw Error('invalid result from bitbox.Address.utxo()');
  }

  return utxosLookupRes.utxos
    .filter(x => x.confirmations !== 0)
    .map(x => [x.txid, x.vout, x.satoshis]);
}

export function unmodernizeBchAddr(addr: string): string {
  validateOrThrowErr(
    'addr',
    isValidAddr('mainnet', addr) || isValidAddr('testnet', addr)
  );
  if (bbAddr.isCashAddress(addr)) {
    return bbAddr.toLegacyAddress(addr);
  }
  return addr;
}

export function modernizeBchAddr(addr: string): string {
  validateOrThrowErr(
    'addr',
    isValidAddr('mainnet', addr) || isValidAddr('testnet', addr)
  );
  if (bbAddr.isLegacyAddress(addr)) {
    return bbAddr.toCashAddress(addr);
  }
  return addr;
}

export function normalizeCashAddr(addr: string): string {
  if (!(isValidAddr('mainnet', addr) || isValidAddr('testnet', addr))) {
    throw Error('the input to normalizeCashAddr() is not a valid address');
  }
  if (!bbAddr.isCashAddress(addr)) {
    throw Error('the input to normalizeCashAddr() is not a CashAddr address');
  }

  const prefixAndSeparator =
    bbAddr.detectAddressNetwork(addr) === 'mainnet'
      ? 'bitcoincash:'
      : 'bchtest:';

  if (addr.startsWith(prefixAndSeparator)) {
    return addr;
  } else {
    return prefixAndSeparator + addr;
  }
}

// ---------------------------------------------------------------------------

function getSupportedNetworks(): string[] {
  return ['mainnet', 'testnet'];
}

function getFeeOptionUnit(): string {
  return 'sat/kB';
}

function isValidFeeOption(network: string, feeOpt: string): boolean {
  validateOrThrowErr('network', isValidNetwork(network));
  return isValidFeeRateToPayStr(feeOpt);
}

function isValidAddr(network: string, addr: string): boolean {
  validateOrThrowErr('network', isValidNetwork(network));
  const a = bbAddr;
  try {
    return (
      ((network === 'mainnet' &&
        a.isMainnetAddress(addr) &&
        a.detectAddressNetwork(addr) === 'mainnet') ||
        (network === 'testnet' &&
          a.isTestnetAddress(addr) &&
          a.detectAddressNetwork(addr) === 'testnet')) &&
      ((a.isCashAddress(addr) && a.detectAddressFormat(addr) === 'cashaddr') ||
        (a.isLegacyAddress(addr) &&
          a.detectAddressFormat(addr) === 'legacy')) &&
      (!a.isCashAddress(addr) ||
        !addr.includes(':') ||
        addr.startsWith(network === 'mainnet' ? 'bitcoincash:' : 'bchtest:')) &&
      ((a.isP2PKHAddress(addr) && a.detectAddressType(addr) === 'p2pkh') ||
        (a.isP2SHAddress(addr) && a.detectAddressType(addr) === 'p2sh'))
    );
  } catch (_) {
    return false;
  }
}

function isValidNormAmount(amount: string): boolean {
  // 0
  // 1
  // 9
  // 19
  // 1000
  // 1000000
  // 55000000
  // 21000000
  // 0.
  // 0.1
  // 0.12
  // 0.777777777777
  // 21000000.00000000
  if (!/^(0|[1-9][0-9]*)(\.[0-9]*)?$/.test(amount)) {
    return false;
  }

  // because a satoshi is not divisible, the following cases are invalid
  // a. there is an dot in the string
  // b. the part after the dot is longer than 8 characters
  // c. there is a nonzero digit after the 8th decimal place
  if (amount.includes('.')) {
    const fractPart = amount.slice(amount.indexOf('.') + 1);
    if (fractPart.length > 8) {
      const afterThe8thDecimalPlace = fractPart.slice(8);
      if (!/^0+$/.test(afterThe8thDecimalPlace)) {
        return false;
      }
    }
  }

  // invalid if greater than 21000000.00000000 BCH
  const wholePart = amount.replace(/\..*$/, '');
  if (
    wholePart.length >= 9 ||
    (wholePart.length === 8 && wholePart > '21000000') ||
    (wholePart === '21000000' && /\..*[1-9]/.test(amount))
  ) {
    return false;
  }

  return true;
}

function convertNormAmountToBaseAmount(amount: string): string {
  if (!isValidNormAmount(amount)) {
    throw Error(`invalid BCH amount: ${amount}`);
  }
  const wholePart = amount.replace(/\..*$/, '');
  const fractPart = amount
    .replace(/^.*\.|^[0-9]$/, '')
    .padEnd(8, '0')
    .slice(0, 8);
  return (wholePart + fractPart).replace(/^0+/, '').padStart(1, '0');
}

function convertBaseAmountToNormAmount(amount: string): string {
  if (!isValidAmountStr(amount)) {
    throw Error(`invalid satoshi amount: ${amount}`);
  }
  const zeroPaddedSatoshis = amount.padStart(16, '0');
  const wholeNumberPart = zeroPaddedSatoshis.slice(0, 8);
  const fractNumberPart = zeroPaddedSatoshis.slice(8);
  const partHead =
    wholeNumberPart === '00000000' ? '0' : wholeNumberPart.replace(/^0+/, '');
  const partTail =
    fractNumberPart === '00000000'
      ? ''
      : '.' + fractNumberPart.replace(/0+$/, '');
  return partHead + partTail;
}

function getUrlForAddr(network: string, addr: string): string {
  validateOrThrowErr('network', isValidNetwork(network));
  validateOrThrowErr('addr', isValidAddr(network, addr));
  if (network === 'mainnet') {
    return `https://explorer.bitcoin.com/bch/address/${addr}`;
  } else {
    return `https://explorer.bitcoin.com/tbch/address/${addr}`;
  }
}

function getUrlForTx(network: string, txid: string): string {
  validateOrThrowErr('network', isValidNetwork(network));
  validateOrThrowErr('txid', isValidTransactionId(txid));
  if (network === 'mainnet') {
    return `https://explorer.bitcoin.com/bch/tx/${txid}`;
  } else {
    return `https://explorer.bitcoin.com/tbch/tx/${txid}`;
  }
}

function encodePubkeyToAddr(network: string, pubkey: string): string {
  validateOrThrowErr('network', isValidNetwork(network));
  validateOrThrowErr('pubkey', isValidPubKey(pubkey));
  const rawCompPubKeyBuf = compressPubKey(Buffer.from(pubkey, 'hex'));
  const hash160hex = bbCrypto.hash160(rawCompPubKeyBuf).toString('hex');
  const legacyPkhVerByte = network === 'mainnet' ? 0x00 : 0x6f;
  return bbAddr.hash160ToCash(hash160hex, legacyPkhVerByte);
}

async function getBalance(network: string, addr: string): Promise<string> {
  validateOrThrowErr('network', isValidNetwork(network));
  validateOrThrowErr('addr', isValidAddr(network, addr));
  const details = await (network === 'mainnet'
    ? bbAddr.details(addr)
    : tbbAddr.details(addr));
  if (
    !((x: any): x is { balanceSat: number } =>
      isObject(x) && isValidAmountNum(x.balanceSat))(details)
  ) {
    throw Error('invalid result from bitbox.Address.details()');
  }
  const balanceBaseUnit = '' + details.balanceSat;
  const balanceNormUnit = convertBaseAmountToNormAmount(balanceBaseUnit);
  return balanceNormUnit;
}

function getHistorySchema(): ITransactionSchema[] {
  return [
    { key: 'txid', label: 'Transaction ID', format: 'hash' },
    { key: 'amount', label: 'Amount', format: 'value' },
    { key: 'date', label: 'Time', format: 'date' },
    { key: 'isConfirmed', label: 'isConfirmed', format: 'boolean' },
  ];
}

async function getRecentHistory(
  network: string,
  addr: string
): Promise<ITransaction[]> {
  validateOrThrowErr('network', isValidNetwork(network));
  validateOrThrowErr('addr', isValidAddr(network, addr));

  const myCashAddr = modernizeBchAddr(addr);
  const myLegacyAddr = unmodernizeBchAddr(addr);
  const myPubKeyHash160 = bbAddr.cashToHash160(myCashAddr);
  const myScriptPubKeyHex = '76a914' + myPubKeyHash160 + '88ac';

  const isValidApiCallResult = (
    x: any
  ): x is {
    txs: Array<{
      txid: string;
      valueOut: number; // 0.06000977
      valueIn: number; // 0.06002222
      fees: number; // 1.245e-05
      time: number; // 1566232521
      confirmations: number; // 5663
      vin: Array<{
        addr: string; // "1C79j1XBq5t4J8P3asSLCCXp2xBogSX57c"
        txid: string;
        vout: number; // 266
        value: number; // 3.952e-05
        valueSat: number; // 3952
      }>;
      vout: Array<{
        type: string; // "pubkeyhash"
        value: string; // "5.32617629"
        scriptPubKey: {
          type: string; // "pubkeyhash"
          hex: string; // "76a914eb85aa84d03f15f946f31797b7676a44335ff75a88ac"
          addresses: string[]; // ["1NUKvN3aLqEKcyAoAN29oVFbFcKdA7dbr8"]
        };
      }>;
    }>;
  } =>
    isObject(x) &&
    isArray(x.txs) &&
    x.txs.every(
      e =>
        isObject(e) &&
        isString(e.txid) &&
        isNumber(e.confirmations) &&
        isValidBlockchainTimestamp(e.time) &&
        isNumber(e.valueOut) &&
        isNumber(e.valueIn) &&
        isNumber(e.fees) &&
        isArray(e.vin) &&
        e.vin.every(
          g =>
            isObject(g) &&
            isString(g.addr) &&
            isString(g.txid) &&
            isNumber(g.vout) &&
            isNumber(g.value) &&
            isNumber(g.valueSat)
        ) &&
        isArray(e.vout) &&
        e.vout.every(
          g =>
            isObject(g) &&
            isString(g.value) &&
            isObject(g.scriptPubKey) &&
            isString(g.scriptPubKey.type) &&
            isString(g.scriptPubKey.hex) &&
            isArray(g.scriptPubKey.addresses) &&
            g.scriptPubKey.addresses.every(isString)
        )
    );

  const result = await (network === 'mainnet' ? bbAddr : tbbAddr).transactions(
    myCashAddr
  );

  if (!isValidApiCallResult(result)) {
    throw Error('invalid result from bitbox.Address.transactions()');
  }

  // Please note that in the API response the .txs[0].vin[0].addr is in legacy
  // format instead of CashAddr format, even when the API call provide address
  // in CashAddr format.  So I must take this into consideration...

  return result.txs.map(tx => {
    const expenseSum = tx.vin
      .filter(x => x.addr === myLegacyAddr)
      .map(x => x.valueSat)
      .reduce((a, b) => a + b, 0);

    const incomeSum = tx.vout
      .filter(x => x.scriptPubKey.hex === myScriptPubKeyHex)
      .map(x => x.value)
      .map(convertNormAmountToBaseAmount)
      .map(x => +x)
      .reduce((a, b) => a + b, 0);

    return {
      txid: { value: tx.txid, link: getUrlForTx(network, tx.txid) },
      amount: {
        value: convertBaseAmountToNormAmount('' + (incomeSum - expenseSum)),
      },
      date: { value: new Date(tx.time * 1000).toISOString() },
      isConfirmed: { value: '' + (tx.confirmations > 0) },
    };
  });
}

async function getFeeOptions(network: string): Promise<string[]> {
  validateOrThrowErr('network', isValidNetwork(network));
  return ['1000', '5000', '50000'];
}

function getPreparedTxSchema(): ITransactionSchema[] {
  return [
    { key: 'amount', label: 'Amount', format: 'value' },
    { key: 'to', label: 'To', format: 'address' },
    { key: 'fee', label: 'Fee', format: 'value' },
  ];
}

function validateSignTxRequest(req: ISignTxRequest): void {
  if (
    !(
      isValidNetwork(req.network) &&
      isValidAccIdx(req.accountIndex) &&
      isValidPubKey(req.fromPubkey) &&
      isValidAddr(req.network, req.toAddr) &&
      isValidNormAmount(req.amount) &&
      isValidFeeRateToPayStr(req.feeOpt)
    )
  ) {
    throw Error(`invalid sign tx request`);
  }

  if (!isValidAmountToPayStr(convertNormAmountToBaseAmount(req.amount))) {
    throw Error(`not a valid amount to send: ${req.amount}`);
  }

  // Prohibit sending funds back to the same address
  const toAddr = normalizeCashAddr(modernizeBchAddr(req.toAddr));
  const fromAddr = encodePubkeyToAddr(req.network, req.fromPubkey);
  if (fromAddr === toAddr) {
    throw Error('sending funds back to the same address is prohibited');
  }
}

function validatePreparedTx(preparedTx: IArmadilloCommand): void {
  if (
    !(
      preparedTx.commandId >= 0x0000 &&
      preparedTx.commandId <= 0xffff &&
      preparedTx.payload.length <= 7000
    )
  ) {
    throw Error('the input prepared tx is invalid');
  }
}

async function prepareCommandSignTx(
  req: ISignTxRequest
): Promise<[IArmadilloCommand, ITransaction]> {
  validateSignTxRequest(req);

  // Conditionally patch the `toAddr` if the input is in the legacy form
  const toAddr = modernizeBchAddr(req.toAddr);

  // Encode pubkey to P2PKH CashAddr address for the specified network
  const fromAddr = encodePubkeyToAddr(req.network, req.fromPubkey);

  // This is the number of satoshis to send
  const satoshiAmount = +convertNormAmountToBaseAmount(req.amount);

  // Determine the destination address mode for selectUtxos() call
  const toAddrContent = Buffer.from(bbAddr.cashToHash160(toAddr), 'hex');
  const outMode: OutMode = bbAddr.isP2PKHAddress(toAddr) ? 'P2PKH' : 'P2SH';

  // Look up UTXOs from the network
  // - the result is an array of [txId, outIdx, value] tuples
  // - the tuple type is [string, number, number]
  const utxos = await getUnspentTxOuts(req.network, fromAddr);

  // Try to select at most 10 UTXOs if the request is fulfillable
  const [selectedUtxoIndices, chgAmount, feeAmount] = selectUtxos(
    utxos.map(x => x[2]),
    'P2PKH',
    outMode,
    satoshiAmount,
    +(req.feeOpt || 0), // dirty hack before using ts 3.7 assertion signatures
    DUST_TXOUT_FEE_RATE,
    DISCARD_CHANGE_FEE_RATE
  );

  // Just a safety/sanity check
  if (
    !(
      isValidAmountNum(chgAmount) &&
      isValidAmountNum(feeAmount) &&
      feeAmount <= MAX_FEE_TOTAL
    )
  ) {
    throw Error('failed to build a transaction with reasonable fee option');
  }

  // Here is the selected subset of [txId, outIdx, value] tuples
  const selectedUtxos: Array<
    [string, number, number]
  > = selectedUtxoIndices.map(i => utxos[i]);

  // Placeholder object to encapsluate txins and txouts of this tx request
  const mBchSignTx = new BchSignTx();

  // Build inputs
  mBchSignTx.setInputsList(
    selectedUtxos.map(([txId, outIdx, value]) => {
      // for each select UTXO as input:
      //
      //      path        uint32_t[3]
      //      prev_tid    uint8_t[32]
      //      prev_index  uint64_t
      //      value       uint64_t
      //
      const mBchTxIn = new BchTxIn();
      mBchTxIn.setPathList([2 ** 31 + req.accountIndex, 0, 0]);
      mBchTxIn.setPrevTid(Buffer.from(txId, 'hex').reverse());
      mBchTxIn.setPrevIndex(outIdx);
      mBchTxIn.setValue(value);
      return mBchTxIn;
    })
  );

  // Build outputs
  // output 0 is for the primary fund recipient
  // output 1 is for change if we have one
  const mBchTxOut0 = new BchTxOut();
  const mBchTxOut1 = new BchTxOut();
  mBchTxOut1.setValue(chgAmount);
  mBchTxOut1.setP2pkhPkhash(
    bbCrypto.hash160(compressPubKey(Buffer.from(req.fromPubkey, 'hex')))
  );
  mBchTxOut0.setValue(satoshiAmount);
  switch (outMode) {
    case 'P2PKH':
      mBchTxOut0.setP2pkhPkhash(toAddrContent);
      break;
    case 'P2SH':
      mBchTxOut0.setP2shShash(toAddrContent);
      break;
    default:
      throw Error('control reaches a point which shall be unreachable');
  }
  mBchSignTx.setOutputsList(
    chgAmount > 0 ? [mBchTxOut0, mBchTxOut1] : [mBchTxOut0]
  );

  const mBchCommand = new BchCommand();
  mBchCommand.setAddrMode(BchCommand.BchAddrMode.CASHADDR);
  mBchCommand.setTestnet(req.network === 'testnet');
  mBchCommand.setSignTx(mBchSignTx);

  const satoshisToKelvinWalletAmount = (s: string): string =>
    truncateToSixDecimals(convertBaseAmountToNormAmount(s));

  return [
    {
      commandId: BITCOINCASH_CMDID,
      payload: Buffer.from(mBchCommand.serializeBinary()),
    },
    {
      to: { value: toAddr },
      amount: { value: satoshisToKelvinWalletAmount('' + satoshiAmount) },
      fee: { value: satoshisToKelvinWalletAmount('' + feeAmount) },
    },
  ];
}

function buildSignedTx(
  req: ISignTxRequest,
  preparedTx: IArmadilloCommand,
  walletRsp: IArmadilloResponse
): string {
  // although unnecessary, we may still validate `req`
  validateSignTxRequest(req);

  // although unnecessary, we may still validate `preparedTx`
  validatePreparedTx(preparedTx);

  const rsp = w('Invalid wallet response: bad BchResponse encoding', () =>
    BchResponse.deserializeBinary(walletRsp.payload)
  );

  const signedTxObj = rsp.getSignedTx();
  if (signedTxObj === undefined) {
    if (rsp.hasError()) {
      throw Error(`Unexpected wallet errorCode response: ${rsp.getError()}`);
    }
    throw Error('Unexpected wallet response');
  }

  return Buffer.from(signedTxObj.getRawtx_asU8()).toString('hex');
}

async function submitTransaction(
  network: string,
  signedTx: string
): Promise<string> {
  validateOrThrowErr('network', isValidNetwork(network));
  validateOrThrowErr('signedTx', isValidHexString(signedTx));

  const isMainnet = network === 'mainnet';

  // This promise may be rejected with an object that looks like one of:
  //
  //      {"error":"TX decode failed"}
  //      {"error":"Missing inputs"}
  //      {"error":"transaction already in block chain"}
  //
  // They are probably thrown from the Axios library because of HTTP 400
  //
  const q = await (isMainnet ? bbRawTx : tbbRawTx).sendRawTransaction(signedTx);

  if (!isValidTransactionId(q)) {
    throw Error(
      `invalid result from bitbox.RawTransactions.sendRawTransaction(): ${q}`
    );
  }

  return q;

  // Use this web site to find tx in mempool of BCH mainnet
  //
  //      open https://blockchair.com/bitcoin-cash/mempool/transactions
  //      curl -si https://rest.bitcoin.com/v2/blockchain/getRawMempool
  //
  // Use this API to find tx in mempool of BCH testnet
  //
  //      curl -si https://trest.bitcoin.com/v2/blockchain/getRawMempool
  //
  // Use this bash function to get raw transaction of BCH mainnet
  //
  //      # usage: bchMainnetRawTx 052e6c749aece4713b5863485b9f30b8f09b50cae6c75ce744e0e43390e557a8
  //      bchMainnetRawTx () {
  //        t=$1
  //        curl -s "https://api.blockchair.com/bitcoin-cash/raw/transaction/$t" | jq -r '.data["'"$t"'"].raw_transaction'
  //      }
  //
  // Use this bash function to get raw transaction of BCH testnet
  //
  //      curl -si https://trest.bitcoin.com/v2/rawtransactions/getrawtransaction/a094c84b4c16a92d86fa04ac8384dcda8f96763b879218bda5decb99ccc1a4bb
  //

  // curl -si https://rest.bitcoin.com/v2/rawtransactions/sendRawTransaction/7f000000
  // HTTP/2 400
  // content-type: application/json; charset=utf-8
  // {"error":"TX decode failed"}

  // curl -si https://rest.bitcoin.com/v2/rawtransactions/sendRawTransaction/01000000013ba3edfd7a7b12b27ac72c3e67768f617fc81bc3888a51323a9fb8aa4b1e5e4a000000006a4730440220540986d1c58d6e76f8f05501c520c38ce55393d0ed7ed3c3a82c69af04221232022058ea43ed6c05fec0eccce749a63332ed4525460105346f11108b9c26df93cd72012103083dfc5a0254613941ddc91af39ff90cd711cdcde03a87b144b883b524660c39ffffffff01807c814a000000001976a914d7e7c4e0b70eaa67ceff9d2823d1bbb9f6df9a5188ac00000000
  // HTTP/2 400
  // content-type: application/json; charset=utf-8
  // {"error":"Missing inputs"}

  // curl -si https://rest.bitcoin.com/v2/rawtransactions/sendRawTransaction/0200000003ebfe8ea80648c1001a9ffd95e13a396cc4a55a8c4fbfffd60c43655601caf2b7010000006a473044022053a3e76687e8dea028efdbb7e605aedb93d567dd5a760521893de93942e467c3022078dcf52038463c013043ad9e3db26e270f331187b3bf52258ab7a8fb3c03f37541210239ae59693709ba1ae2cf708ba9718db0e043a00e228e47a37165ed74e4510f69ffffffffd5caac1b0cbedf61673745f0bde607b35c9c1998d88387acee2adebd788c71b9020000006a4730440220044d2db98acc4d860c7a852ff5472899a906689b51158e837c38e5bc2c49d5e7022056a0a7e3ef67866623d6947e9e5c976251a79b7c4c14a9a8ba6c655bc5ae1d2a41210239ae59693709ba1ae2cf708ba9718db0e043a00e228e47a37165ed74e4510f69ffffffff2b891a1d56a7bec3409b991bd98e01021fb6e586f94778ce521b5e560e4f2c02020000006b48304502210083467eddeb991a25a34e9ed8c820239dcc743583eaacf6cca1b643484aaee1ad022045ea6e4957d0712a2ef3eea870f51baee985ff97a6c6244fcaed2086f2e2ed0041210239ae59693709ba1ae2cf708ba9718db0e043a00e228e47a37165ed74e4510f69ffffffff040000000000000000406a04534c500001010453454e44207853218e23fdabb103b4bccbe6e987da8974c7bc775b7e7e64722292ac53627f080000000e7ed8f59008000017c3f2cc8d2222020000000000001976a91422af431b20395575c0180f1d2e35192b7be593a588ac22020000000000001976a9147fcedb5aed89d144eb808fe5e49cdf6834eb00b888ac3fef3200000000001976a9147fcedb5aed89d144eb808fe5e49cdf6834eb00b888ac00000000
  // HTTP/2 400
  // content-type: application/json; charset=utf-8
  // {"error":"transaction already in block chain"}

  // $ curl -si https://rest.bitcoin.com/v2/rawtransactions/sendRawTransaction/01000000014c3a3abfb6722c76c031e0ad9443c49330981e1d988f4d9e9990b464032bf033010000008a47304402205ab20a78b02ca613ee7423340e8eb55e17b7753b92b761177b1132c9f1f7c794022051dd5436e554948df1f195ac7da5b1b5e3dfe3a190260d4f4809b4639b09897741410467ff2df20f28bc62ad188525868f41d461f7dab3c1e500314cdb5218e5637bfd0f9c02eb5b3f383f698d28ff13547eaf05dd9216130861dd0216824e9d7337e3ffffffff020000000000000000276a045d8f122a2046004a0036a00dfd3cdaf8df39b53f123ca93f293be032db35dc1df937f9d010180a0000000000001976a914066ebee590278f32aedc8a4865700c49e717f1d788ac00000000
  // HTTP/2 200
  // content-type: application/json; charset=utf-8
  // "4901f3071ba40b281f68599cd584cbface62841c6ccb132669dba5169e77e163"
}

function prepareCommandGetPubkey(
  network: string,
  accountIndex: number
): IArmadilloCommand {
  validateOrThrowErr('network', isValidNetwork(network));
  validateOrThrowErr('accountIndex', isValidAccIdx(accountIndex));

  const mBchGetXPub = new BchGetXPub();
  mBchGetXPub.setPathList([2 ** 31 + accountIndex, 0, 0]);

  const mBchCommand = new BchCommand();
  mBchCommand.setAddrMode(BchCommand.BchAddrMode.CASHADDR);
  mBchCommand.setTestnet(network === 'testnet');
  mBchCommand.setGetXpub(mBchGetXPub);

  return {
    commandId: BITCOINCASH_CMDID,
    payload: Buffer.from(mBchCommand.serializeBinary()),
  };
}

function parsePubkeyResponse(walletRsp: IArmadilloResponse): string {
  const rsp = w('Invalid wallet response: bad BchResponse encoding', () =>
    BchResponse.deserializeBinary(walletRsp.payload)
  );

  const xpubObj = rsp.getXpub();
  if (xpubObj === undefined) {
    if (rsp.hasError()) {
      throw Error(`Unexpected wallet errorCode response: ${rsp.getError()}`);
    }
    throw Error('Unexpected wallet response');
  }

  return (
    '04' +
    Buffer.from(xpubObj.getXpub_asU8())
      .slice(0, 64)
      .toString('hex')
  );
}

function prepareCommandShowAddr(
  network: string,
  accountIndex: number
): IArmadilloCommand {
  validateOrThrowErr('network', isValidNetwork(network));
  validateOrThrowErr('accountIndex', isValidAccIdx(accountIndex));

  const mBchShowAddr = new BchShowAddr();
  mBchShowAddr.setPathList([2 ** 31 + accountIndex, 0, 0]);

  const mBchCommand = new BchCommand();
  mBchCommand.setAddrMode(BchCommand.BchAddrMode.CASHADDR);
  mBchCommand.setTestnet(network === 'testnet');
  mBchCommand.setShowAddr(mBchShowAddr);

  return {
    commandId: BITCOINCASH_CMDID,
    payload: Buffer.from(mBchCommand.serializeBinary()),
  };
}

// ---------------------------------------------------------------------------

export const bchCurrencyUtil: ICurrencyUtil = {
  getSupportedNetworks,
  getFeeOptionUnit,
  isValidFeeOption,
  isValidAddr,
  isValidNormAmount,
  convertNormAmountToBaseAmount,
  convertBaseAmountToNormAmount,
  getUrlForAddr,
  getUrlForTx,
  encodePubkeyToAddr,
  getBalance,
  getHistorySchema,
  getRecentHistory,
  getFeeOptions,
  getPreparedTxSchema,
  prepareCommandSignTx,
  buildSignedTx,
  submitTransaction,
  prepareCommandGetPubkey,
  parsePubkeyResponse,
  prepareCommandShowAddr,
};

export default bchCurrencyUtil;
